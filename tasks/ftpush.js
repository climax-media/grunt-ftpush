// Generated by CoffeeScript 1.9.1
var FS, FTP, Path, async, crypto, util;

require('sugar');

Path = require('path');

FS = require('fs');

FTP = require('jsftp');

async = require('async');

util = require('util');

crypto = require('crypto');

module.exports = function(grunt) {
  var Synchronizer;
  grunt.registerMultiTask("ftpush", "Mirror code over FTP", function(target) {
    var auth, credentials, done, exclusions, keep, localRoot, options, remoteRoot, sync;
    done = this.async();
    auth = function(key) {
      var config;
      if (grunt.file.exists(".ftppass")) {
        config = grunt.file.read(".ftppass");
        if ((key != null) && config.length) {
          return JSON.parse(config)[key];
        }
      }
    };
    grunt.log.debug("Collecting information...");
    localRoot = Array.isArray(this.data.src) ? this.data.src[0] : this.data.src;
    remoteRoot = Array.isArray(this.data.dest) ? this.data.dest[0] : this.data.dest;
    credentials = this.data.auth.authKey ? auth(this.data.auth.authKey) : auth(this.data.auth.host);
    exclusions = this.data.exclusions || [];
    keep = this.data.keep || [];
    options = {
      useList: !!this.data.useList,
      remove: !(grunt.option('simple') || this.data.simple)
    };
    grunt.log.debug("Initializing synchronizer...");
    sync = new Synchronizer(localRoot, remoteRoot, Path.join(".grunt", "ftpush", this.target + ".json"), Object.merge(this.data.auth, credentials), exclusions, keep, options);
    grunt.log.debug("Synchronizer initialized...");
    return sync.sync(done);
  });
  return Synchronizer = (function() {
    Synchronizer.prototype.debug = false;

    function Synchronizer(localRoot1, remoteRoot1, memoryPath, auth1, exclusions1, keep1, options) {
      this.localRoot = localRoot1;
      this.remoteRoot = remoteRoot1;
      this.memoryPath = memoryPath;
      this.auth = auth1;
      this.exclusions = exclusions1;
      this.keep = keep1;
      this.localRoot = Path.resolve(this.localRoot);
      grunt.log.debug("Local root set to '" + this.localRoot + "'");
      this.localFiles = this.buildTree();
      grunt.log.debug((Object.keys(this.localFiles).length) + " paths found");
      this.remove = options.remove;
      this.ftp = new FTP({
        host: this.auth.host,
        port: this.auth.port
      });
      this.ftp.useList = options.useList;
      this.memory = grunt.file.exists(this.memoryPath) ? JSON.parse(grunt.file.read(this.memoryPath)) : {};
    }

    Synchronizer.prototype.normalizeFtpPath = function(path) {
      return path.split(Path.sep).join('/');
    };

    Synchronizer.prototype.hash = function(path) {
      var hash;
      hash = crypto.createHash('md5');
      hash.update(grunt.file.read(path));
      return hash.digest('hex');
    };

    Synchronizer.prototype.remember = function(path, file, hash) {
      var base;
      (base = this.memory)[path] || (base[path] = {});
      this.memory[path][file] = hash;
      return grunt.file.write(this.memoryPath, JSON.stringify(this.memory));
    };

    Synchronizer.prototype.prepare = function(callback) {
      return this.ftp.auth(this.auth.username, this.auth.password, (function(_this) {
        return function(err) {
          if (err) {
            grunt.fatal("Authentication error: " + err);
          }
          grunt.log.ok("Authenticated as " + _this.auth.username);
          return callback();
        };
      })(this));
    };

    Synchronizer.prototype.sync = function(callback) {
      var finish;
      grunt.log.debug("Uploading started...");
      finish = (function(_this) {
        return function(err) {
          if (err) {
            grunt.warn(err);
          }
          return _this.ftp.raw.quit(function() {
            return callback();
          });
        };
      })(this);
      return this.prepare((function(_this) {
        return function() {
          var commands, diff, files, upload;
          if (_this.remove) {
            grunt.log.debug("Switching to full synchronization mode...");
            diff = function(path, done) {
              return _this.diff(path, function(diff) {
                return _this.perform(path, diff, function() {
                  return done();
                });
              });
            };
            return async.each(Object.keys(_this.localFiles), diff, finish);
          } else {
            grunt.log.debug("Switching to simple mode...");
            commands = [];
            files = _this.findLocallyModified();
            upload = function(path, done) {
              return _this.touchRecursive(Path.join(_this.remoteRoot, path), function() {
                files[path].each(function(file) {
                  return commands.push(function(done) {
                    return _this.upload(file.name, path, file.hash, done);
                  });
                });
                return done();
              });
            };
            return async.each(Object.keys(files), upload, function() {
              return async.parallel(commands, finish);
            });
          }
        };
      })(this));
    };

    Synchronizer.prototype.perform = function(path, diff, callback) {
      var commands;
      commands = [];
      diff.upload.each((function(_this) {
        return function(entry) {
          return commands.push(function(done) {
            return _this.upload(entry[0], path, entry[1], done);
          });
        };
      })(this));
      diff.rm.each((function(_this) {
        return function(basename) {
          return commands.push(function(done) {
            return _this.rm(basename, path, done);
          });
        };
      })(this));
      diff.rmDir.each((function(_this) {
        return function(basename) {
          return commands.push(function(done) {
            return _this.rmDir(basename, path, done);
          });
        };
      })(this));
      return async.parallel(commands, function() {
        return callback();
      });
    };

    Synchronizer.prototype.buildTree = function(root, result) {
      var filename, i, len, name, name1, path, ref;
      if (root == null) {
        root = this.localRoot;
      }
      if (result == null) {
        result = {};
      }
      result[name = Path.sep] || (result[name] = []);
      if (!grunt.file.exists(root)) {
        grunt.fatal(root + " is not an existing location");
      }
      ref = FS.readdirSync(root);
      for (i = 0, len = ref.length; i < len; i++) {
        filename = ref[i];
        path = Path.join(root, filename);
        if (!grunt.file.isMatch({
          matchBase: true
        }, this.exclusions, Path.relative(this.localRoot, path))) {
          if (grunt.file.isDir(path)) {
            grunt.log.debug("Building tree: Recursing into " + path);
            result[name1 = Path.sep + Path.relative(this.localRoot, path)] || (result[name1] = []);
            this.buildTree(path, result);
          } else {
            grunt.log.debug("Building tree: Added " + path);
            result[Path.sep + Path.relative(this.localRoot, root)].push({
              name: filename,
              hash: this.hash(path)
            });
          }
        }
      }
      return result;
    };

    Synchronizer.prototype.findLocallyModified = function() {
      var changed;
      changed = {};
      Object.each(this.localFiles, (function(_this) {
        return function(path, files) {
          var file, i, len, ref, results1;
          results1 = [];
          for (i = 0, len = files.length; i < len; i++) {
            file = files[i];
            if (file.hash !== ((ref = _this.memory[path]) != null ? ref[file.name] : void 0)) {
              changed[path] || (changed[path] = []);
              results1.push(changed[path].push(file));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        };
      })(this));
      return changed;
    };

    Synchronizer.prototype.diff = function(path, callback) {
      var localFiles;
      localFiles = this.localFiles[path];
      return this.touch(Path.join(this.remoteRoot, path), (function(_this) {
        return function(remoteFiles) {
          var diff;
          diff = {
            upload: [],
            rm: [],
            rmDir: []
          };
          remoteFiles.each(function(rf) {
            var lf;
            rf.name = Path.basename(rf.name);
            if (!grunt.file.isMatch({
              matchBase: true
            }, _this.keep, Path.join(path, rf.name))) {
              if (rf.type === 0) {
                lf = localFiles.find(function(x) {
                  return rf.name === x.name;
                });
                if (!lf) {
                  return diff.rm.push(rf.name);
                }
              } else if (rf.type === 1) {
                if (!_this.localFiles[Path.join(path, rf.name)]) {
                  return diff.rmDir.push(rf.name);
                }
              }
            }
          });
          localFiles.each(function(lf) {
            var ref, rf;
            rf = remoteFiles.find(function(x) {
              return lf.name === x.name;
            });
            if (!rf || lf.hash !== ((ref = _this.memory[path]) != null ? ref[lf.name] : void 0)) {
              return diff.upload.push([lf.name, lf.hash]);
            }
          });
          grunt.log.ok("Got diff for " + path.yellow + " " + (diff.upload.length.toString().green) + " " + (diff.rm.length.toString().red) + " " + (diff.rmDir.length.toString().cyan));
          grunt.log.debug("Diff", util.inspect(diff));
          return callback(diff);
        };
      })(this));
    };

    Synchronizer.prototype.touchRecursive = function(path, callback) {
      var commands, i, len, segment, segments, step;
      segments = path.split(Path.sep);
      step = [];
      commands = [];
      for (i = 0, len = segments.length; i < len; i++) {
        segment = segments[i];
        if (segment.length > 0) {
          (function(_this) {
            return (function(segment) {
              var localPath;
              step.push(segment);
              localPath = step.join(Path.sep);
              return commands.push(function(done) {
                return _this.touch(localPath, done);
              });
            });
          })(this)(segment);
        }
      }
      return async.parallel(commands, callback);
    };

    Synchronizer.prototype.touch = function(path, callback) {
      grunt.log.debug("Touch", util.inspect(path));
      return this.ftp.ls(this.normalizeFtpPath(path), (function(_this) {
        return function(err, results) {
          if (!err && ((results != null ? results.length : void 0) != null) && results.length > 0) {
            return callback(results.compact());
          }
          grunt.log.debug("Make directory", util.inspect(path));
          return _this.ftp.raw.mkd(_this.normalizeFtpPath(path), function(err) {
            if (err) {
              grunt.log.debug("Remote folder wasn't creted (isn't empty?) " + path + " --> " + err);
            } else {
              grunt.log.ok("New remote folder created " + path.yellow);
            }
            return callback([]);
          });
        };
      })(this));
    };

    Synchronizer.prototype.upload = function(basename, path, hash, callback) {
      var remoteFile;
      grunt.log.debug("Upload", util.inspect(basename), util.inspect(path), util.inspect(hash));
      remoteFile = this.normalizeFtpPath(Path.join(this.remoteRoot, path, basename));
      return this.ftp.put(remoteFile, FS.readFileSync(Path.join(this.localRoot, path, basename)), (function(_this) {
        return function(err) {
          if (err) {
            return grunt.warn("Cannot upload file: " + basename + " --> " + err);
          } else {
            _this.remember(path, basename, hash);
            grunt.log.ok("Uploaded file: " + basename.green + " to: " + path.yellow);
            return callback();
          }
        };
      })(this));
    };

    Synchronizer.prototype.rm = function(basename, path, callback) {
      grunt.log.debug("Delete", util.inspect(basename), util.inspect(path));
      return this.ftp.raw.dele(this.normalizeFtpPath(Path.join(this.remoteRoot, path, basename)), function(err) {
        if (err) {
          return grunt.warn("Cannot delete file: " + basename + " --> " + err);
        } else {
          grunt.log.ok("Removed file: " + basename.green + " from: " + path.yellow);
          return callback();
        }
      });
    };

    Synchronizer.prototype.rmDir = function(basename, path, callback) {
      var remotePath;
      grunt.log.debug("Delete directory", util.inspect(basename), util.inspect(path));
      remotePath = this.normalizeFtpPath(Path.join(this.remoteRoot, path, basename));
      return this.ftp.ls(remotePath, (function(_this) {
        return function(err, results) {
          var commands;
          if (err) {
            grunt.warn("Cannot list directory " + remotePath + " for removal --> " + err);
          }
          commands = [];
          results.compact().each(function(rf) {
            if (rf.type === 0) {
              return commands.push(function(done) {
                return _this.rm(rf.name, Path.join(path, basename), done);
              });
            } else {
              return commands.push(function(done) {
                return _this.rmDir(rf.name, Path.join(path, basename), done);
              });
            }
          });
          return async.parallel(commands, function() {
            return _this.ftp.raw.rmd(remotePath, function(err) {
              if (err) {
                grunt.warn("Cannot remove directory " + remotePath + " --> " + err);
              }
              grunt.log.ok("Removed directory: " + basename.green + " from: " + path.yellow);
              return callback();
            });
          });
        };
      })(this));
    };

    return Synchronizer;

  })();
};
